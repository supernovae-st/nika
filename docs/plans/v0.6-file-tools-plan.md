# Nika v0.6 File Tools Implementation Plan

**Status:** In Progress
**Target:** Close the gap between Nika Chat and Claude Code
**Based on:** Gemini CLI (Yolo Mode), Mistral Vibe patterns, Claude Code tools

---

## Executive Summary

Add 5 filesystem tools to Nika to enable coding assistant capabilities:
- **Read** - Read files with line numbers
- **Write** - Create new files
- **Edit** - Modify existing files (requires read-before-edit)
- **Glob** - Find files by pattern
- **Grep** - Search file contents

Plus: `nika init` command and MCP server exposure.

---

## Research Findings

### Gemini CLI Patterns
- **Yolo Mode** (`Ctrl+Y` or `--yolo`): Auto-approve file edits/searches
- **Sandboxing**: Docker/Podman isolation for risky commands
- **Checkpointing**: `/restore` commands for instant rollback
- **Decision Tree**: Routes TUI to interactive shell, risky to sandbox

### Mistral Vibe Patterns
- Tools defined via Markdown prompts in `core/prompts/<tool>.md`
- Structured JSON output for paths and diffs
- Confirmation steps for destructive operations
- Clean separation of tool logic and prompts

### Claude Code Patterns
- **Read-before-edit**: Must read file before editing (atomic operations)
- **Absolute paths only**: Security boundary enforcement
- **Line-number format**: cat -n style output
- **Deterministic sorting**: By modification time for reproducibility

---

## Architecture

```
src/tools/
├── mod.rs              # ToolExecutor trait, PermissionMode, dispatch
├── context.rs          # ToolContext (working_dir, read_files tracking)
├── read.rs             # Read tool implementation
├── write.rs            # Write tool implementation
├── edit.rs             # Edit tool with read-before-edit validation
├── glob.rs             # Glob tool (ignore crate)
└── grep.rs             # Grep tool (regex + ignore)
```

### Permission Model

```rust
pub enum PermissionMode {
    /// Deny all file operations
    Deny,
    /// Ask before each operation (Plan mode)
    Plan,
    /// Auto-approve edits, ask for others (AcceptEdits)
    AcceptEdits,
    /// Auto-approve all operations (Yolo mode)
    AcceptAll,
}
```

Inspired by Gemini's Yolo Mode + Claude Code's permission levels.

### Tool Context

```rust
pub struct ToolContext {
    /// Working directory (security boundary)
    working_dir: PathBuf,
    /// Files that have been read (for edit validation)
    read_files: HashSet<PathBuf>,
    /// Current permission mode
    permission_mode: PermissionMode,
    /// Event log for observability
    event_tx: mpsc::Sender<ToolEvent>,
}
```

---

## Tool Specifications

### 1. Read Tool

```rust
pub struct ReadTool {
    ctx: Arc<ToolContext>,
}

impl ReadTool {
    /// Read file with optional offset and limit
    pub async fn execute(&self, params: ReadParams) -> Result<ReadResult, ToolError> {
        // 1. Validate path (absolute, within working_dir)
        // 2. Read file content
        // 3. Apply offset/limit
        // 4. Format with line numbers (cat -n style)
        // 5. Track in read_files set
        // 6. Emit ToolRead event
    }
}

pub struct ReadParams {
    pub file_path: String,      // Absolute path
    pub offset: Option<usize>,  // Start line (1-indexed)
    pub limit: Option<usize>,   // Max lines (default: 2000)
}

pub struct ReadResult {
    pub content: String,        // Line-numbered content
    pub total_lines: usize,
    pub truncated: bool,
}
```

### 2. Write Tool

```rust
pub struct WriteTool {
    ctx: Arc<ToolContext>,
}

impl WriteTool {
    /// Create a new file (fails if exists)
    pub async fn execute(&self, params: WriteParams) -> Result<WriteResult, ToolError> {
        // 1. Validate path
        // 2. Check permission mode
        // 3. Fail if file exists (use Edit for modifications)
        // 4. Atomic write (temp file + rename)
        // 5. Emit ToolWrite event
    }
}

pub struct WriteParams {
    pub file_path: String,
    pub content: String,
}
```

### 3. Edit Tool

```rust
pub struct EditTool {
    ctx: Arc<ToolContext>,
}

impl EditTool {
    /// Edit existing file (requires read-before-edit)
    pub async fn execute(&self, params: EditParams) -> Result<EditResult, ToolError> {
        // 1. Validate path
        // 2. Check read_files - MUST have read this file first
        // 3. Check permission mode
        // 4. Find old_string (must be unique or replace_all)
        // 5. Replace with new_string
        // 6. Atomic write
        // 7. Emit ToolEdit event
    }
}

pub struct EditParams {
    pub file_path: String,
    pub old_string: String,
    pub new_string: String,
    pub replace_all: bool,      // Default: false
}

pub struct EditResult {
    pub replacements: usize,
    pub diff_preview: String,   // Unified diff format
}
```

### 4. Glob Tool

```rust
pub struct GlobTool {
    ctx: Arc<ToolContext>,
}

impl GlobTool {
    /// Find files matching pattern
    pub async fn execute(&self, params: GlobParams) -> Result<GlobResult, ToolError> {
        // 1. Validate base path
        // 2. Build glob matcher (ignore crate)
        // 3. Walk directory tree
        // 4. Collect matches
        // 5. Sort by modification time
        // 6. Emit ToolGlob event
    }
}

pub struct GlobParams {
    pub pattern: String,        // e.g., "**/*.rs"
    pub path: Option<String>,   // Base path (default: working_dir)
}

pub struct GlobResult {
    pub matches: Vec<String>,   // Absolute paths
    pub count: usize,
}
```

### 5. Grep Tool

```rust
pub struct GrepTool {
    ctx: Arc<ToolContext>,
}

impl GrepTool {
    /// Search file contents with regex
    pub async fn execute(&self, params: GrepParams) -> Result<GrepResult, ToolError> {
        // 1. Validate base path
        // 2. Build regex (case-insensitive, multiline options)
        // 3. Walk files (with glob filter if provided)
        // 4. Search each file
        // 5. Collect results based on output_mode
        // 6. Emit ToolGrep event
    }
}

pub struct GrepParams {
    pub pattern: String,                // Regex pattern
    pub path: Option<String>,           // Base path
    pub glob: Option<String>,           // File filter
    pub output_mode: GrepOutputMode,    // content, files, count
    pub case_insensitive: bool,
    pub context_before: Option<usize>,  // -B
    pub context_after: Option<usize>,   // -A
}

pub enum GrepOutputMode {
    Content,            // Show matching lines
    FilesWithMatches,   // Just file paths (default)
    Count,              // Match count per file
}
```

---

## nika init Command

```rust
/// Initialize a new Nika project
Init {
    /// Project name (creates directory)
    name: Option<String>,

    /// Template to use
    #[arg(short, long, default_value = "basic")]
    template: String,
}
```

Creates:
```
my-project/
├── .nika/
│   └── config.yaml         # Project config
├── workflows/
│   └── hello.nika.yaml     # Example workflow
├── .env.example            # API key template
└── README.md               # Quick start guide
```

Templates:
- `basic` - Single infer task
- `agent` - Agent with MCP tools
- `pipeline` - Multi-task DAG with for_each

---

## MCP Server Exposure

Expose tools as MCP server for other agents:

```rust
// src/mcp/server.rs
pub struct NikaToolsServer {
    tools: Vec<Arc<dyn ToolDyn>>,
}

impl NikaToolsServer {
    pub fn new(working_dir: PathBuf) -> Self {
        let ctx = Arc::new(ToolContext::new(working_dir));
        Self {
            tools: vec![
                Arc::new(ReadTool::new(ctx.clone())),
                Arc::new(WriteTool::new(ctx.clone())),
                Arc::new(EditTool::new(ctx.clone())),
                Arc::new(GlobTool::new(ctx.clone())),
                Arc::new(GrepTool::new(ctx.clone())),
            ],
        }
    }
}
```

MCP tool naming: `nika_read`, `nika_write`, `nika_edit`, `nika_glob`, `nika_grep`

---

## Integration with RigAgentLoop

```rust
// In runtime/rig_agent_loop.rs
impl RigAgentLoop {
    pub fn with_file_tools(mut self, working_dir: PathBuf) -> Self {
        let ctx = Arc::new(ToolContext::new(working_dir));

        // Add file tools to agent
        self.tools.push(Box::new(ReadTool::new(ctx.clone())));
        self.tools.push(Box::new(WriteTool::new(ctx.clone())));
        self.tools.push(Box::new(EditTool::new(ctx.clone())));
        self.tools.push(Box::new(GlobTool::new(ctx.clone())));
        self.tools.push(Box::new(GrepTool::new(ctx.clone())));

        self
    }
}
```

---

## Error Codes

| Code | Error |
|------|-------|
| NIKA-200 | Read failed |
| NIKA-201 | Write failed |
| NIKA-202 | Edit failed |
| NIKA-203 | Must read before edit |
| NIKA-204 | Path out of bounds |
| NIKA-205 | Permission denied |
| NIKA-206 | Invalid glob pattern |
| NIKA-207 | Invalid regex |
| NIKA-208 | File not found |
| NIKA-209 | old_string not unique |

---

## Implementation Order

### Phase 1: Core Infrastructure (~200 LOC)
1. `src/tools/mod.rs` - ToolExecutor trait, PermissionMode
2. `src/tools/context.rs` - ToolContext with working_dir + read_files

### Phase 2: Basic Tools (~400 LOC)
3. `src/tools/read.rs` - Read with line numbers
4. `src/tools/write.rs` - Atomic write
5. `src/tools/glob.rs` - Pattern matching

### Phase 3: Advanced Tools (~300 LOC)
6. `src/tools/edit.rs` - Edit with read-before-edit
7. `src/tools/grep.rs` - Regex search

### Phase 4: CLI Integration (~150 LOC)
8. Add `nika init` command
9. Integrate tools into RigAgentLoop
10. Add to ChatAgent for TUI

### Phase 5: MCP Server (~200 LOC)
11. Expose tools via MCP server
12. Add `nika serve` command

### Phase 6: Testing (~500 LOC)
13. Unit tests for each tool
14. Integration tests
15. E2E test with real agent

---

## Success Criteria

- [ ] All 5 tools implemented and tested
- [ ] Permission model works (Plan, AcceptEdits, AcceptAll)
- [ ] `nika init` creates valid project structure
- [ ] Tools available in TUI chat via `/agent`
- [ ] MCP server exposes tools
- [ ] 50+ tests passing
- [ ] Documentation updated

---

## Timeline

- Phase 1-2: Today (core + basic tools)
- Phase 3-4: Tomorrow (advanced + CLI)
- Phase 5-6: Day 3 (MCP + tests)

---

## Dependencies (Already in Cargo.toml)

- `tokio` - Async I/O
- `walkdir` - Directory traversal
- `ignore` - Glob + .gitignore
- `regex` - Pattern matching
- `camino` - UTF-8 paths

No new dependencies required!
